---
layout: post
# title:  "비트마스크 기초편"
date:   2018-03-22 23:10:00 +0900
categories: 비트마스크
tag: 비트마스크
---

## 어려운 비트마스크

비트마스크는 알고리즘을 풀 때 간간히 필요합니다.

비트마스크 없이는 못 푸는 문제를 점점 많이 접하게 되서 공부차 올립니다.

## 비트마스크를 사용한 코드의 장점

- 더 빠른 수행 시간
- 더 간결한 코드
- 더 작은 메모리 사용량
- 연관 배열을 배열로 대체 : boolean으로 체크하는 배열을 비트마스크를 써서 int[]로 나타낼 수 있다. 큰 시간과 메모리 차이를 불러온다.

## 비트마스크 사용법

**8개의 비트를 사용하고자 한다.**

int bitmask를 비트마스크 변수로 선언한다.

비트는 맨 오른쪽 비트가 0번 비트고 총 8개 비트면 0~7의 범위를 갖는다.

bitmask 변수의 우측 8개 비트만 사용한다는 것이다.

**비트 상태가 0인것을 꺼져있다고 하고 1인것을 켜져있다고 한다.**

![bitmask](https://quarl894.github.io/assets/posts/20180322/bitmask.png)

이런식이 된다.

배열로 표현한다면 idx[8]={1,2,4,8,16,32,64,128}; 이 된다.

idx[n]==(1<<n) 이다. 연산자 우선순위에 유의한다

#### 비트 조회

n번 비트가 켜져있는지 조회하고자 하면 **if(bitmask&idx[n])**

n번째 비트가 켜져있으면 0보다 큰 값을 꺼져있으면 0을 얻을 수 있다.

#### 비트 모두 켜기

즉 1111 1111의 상태로 만들고자 한다.

이 경우 10진수인 255를 바로 삽입하는 형태로 쓸 수도 있다.

bitmask=255;

※int의 비트 수는 128개이고 그 중 우측 8개 비트만 사용하기 때문에 음수인 경우를 고려하지 않아도 되는것임을 유의.

시프트 연산으로 1111 1111를 만드는법은

100000000를 만들고 여기서 1을 빼주면 된다.

**즉 bitmask=(1<<8)-1;**

#### 비트 모두 끄기

**bitmask=0;**

#### n번 비트 켜기

**bitmask|=idx[n];**

#### n번 비트 끄기

**bitmask&=~idx[n];**

#### n번 비트 토글 (켜졌으면 끄고 꺼졌으면 킨다)

**bitmask^=idx[n];**

#### 비트 마스크 끼리의 집합

> 합집합: (bitmask1 | bitmask2)

> 교집합: (bitmask1&bitmask2)

> 차집합: (bitmask1&~bitmask2)    전자에서 후자를 뺀 집합을 뜻함

> 둘 중 하나에만 켜져있는 집합: (bitmask1^bitmask2)

#### 비트마스크 기본 문제

[이진수 연산](https://www.acmicpc.net/problem/12813)

[집합](https://www.acmicpc.net/problem/11723)

[데스스타](https://www.acmicpc.net/problem/11811)

[jekyll-gh]:   https://github.com/quarl894