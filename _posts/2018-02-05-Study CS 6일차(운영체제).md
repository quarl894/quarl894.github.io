---
layout: post
# title:  "Study CS 6일차(운영체제)"
date:   2018-02-05 22:20:00 +0900
categories: 운영체제, 동기화, 스레드
tag: 운영체제
---

## Process vs Thread

#### 프로세스

운영체제로부터 할당받은 작업의 단위

#### 스레드

프로세스가 할당받는 자원을 이용하는 실행의 단위

## 멀티 프로세스 vs 멀티 스레드

### 멀티 프로세스

#### 장점

- 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다

#### 단점

- 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다

### 멀티 스레드

#### 장점

- 자원소모가 줄어든다.
- 스레드 간 통신이 전역 변수의 공간 또는 동적으로 할당된 Heap영역을 이용하기 때문에 훨씬 간단함.
- 문맥교환 시 캐시를 비울 필요가 없다.

#### 단점

- 동기화 작업 필요
- 많은 작업시 병목현상이 일어나 락에 걸릴 수 있음.
- 오류로 인해 하나의 스레드가 종료될 시 스레드 전체가 종료됨.

## 동기와 비동기의 차이를 설명하시오.

### 동기

메소드를 실행시킨 후에 반환되기까지 blocking 됨. 반환 후 실행함.

#### 비동기

메소드를 실행시킨 후 멈추지 않고 해당 메소드를 이벤트 큐나 백그라운드 스레드에게 해당 task를 위임하고 자기할일을 함.

## 가상메모리의 정의와 장점

#### 정의

프로세스 전체가 메모리 내에 올라오지 않더리도 실행이 가능하도록 하기 위해 필요한 일부 메모리만 적재하여 사용하는 기법

#### 장점

1. 물리 메모리의 크기에 제약받지 않게 된다.
2. 더 많은 프로그램 동시에 실행 -> 응답시간 유지, CPU 이용율 처리율 향상, 프로그램 빠르게 실행 가능

## 스레드에서 스택과 레지스터가 독립적으로 할당되어야 하는 이유.

#### 스택

스택이란 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 **스택 공간이 독립적인것은 독립적인 함수호출이 가능하고 독립적인 실행 흐름이 추가된다는 것이다.**

#### 레지스터

PC값은 스레드가 명령어의 어디까지 수행했는지 나타나게 된다.

스레드는 CPU의 할당을 받았다가 스케줄러에 의해 선점을 당하는데 그 과정에서 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행하였는지를 기억할 필요가 있기때문에 독립적이어야 한다.

## Round Robin을 사용시 주의점은?

**적당한 time quantum을 설정하는 것.**

설정한 time quantum이 너무 커지면 FCFS와 같아지고, 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch로 overhead가 발생하기 때문)

## Deadlock 이란?

세마포가 Ready Queue를 가지고 있고, 둘 이상의 프로세스가 Critical Section 진입을 무한정 기다리고 있고, Critical Section 에서 실행되는 프로세스는 진입 대기 중인 프로세스가 실행되야만 빠져나올 수 있는 상황

## LRU, LFU 페이지 교체 알고리즘은 어떤 것인가?

#### LRU

가장 오랫동안 사용되지않은 페이지 선택하여 교체

#### LFU

참조회수가 가장 작은 페이지를 교체

## 프로세스를 큐를 이용하여 스케줄링하는 방법이 세가지가 있다. 종류별 역할과 상태를 설명하시오.

#### 장기스케쥴러

메모리와 디스크 사이의 스케쥴링을 담당함으로서, 디스크에 임시로 pool에 저장되어 있는 프로세스 중 어떤 프로세스를 메모리에 할당하여 ready 큐에 보낼지 결정하는 역할

프로세스 상태: new -> ready

#### 단기 스케쥴러

CPU와 메모리 사이의 스케쥴링을 담당함으로서, ready큐에 존재하는 프로세스 중 어떤 프로세스를 running시킬지 결정하는 역할

프로세스 상태: ready -> running -> waiting -> ready

#### 중기스케쥴러

메모리에서 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케쥴러로서, 여유공간을 마련하기 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다(deallocate)

프로세스 상태: ready -> suspended

## 임계영역에 대한 정의와 해결을 위한 기본조건

#### 정의

멀티 스레딩에 문제점에서 나오듯, 동일한 자원을 동시에 접근하는 작업(e.g. 공유하는 변수 사용, 동일 파일을 사용하는 등)을 실행하는 코드 영역을 Critical Section이라 칭한다.

#### Critical Section Problem(임계영역 문제)

프로세스들이 Critical Section을 함께 사용할 수 있는 프로토콜을 설계하는 것이다.

#### Requirements(해결을 위한 기본조건)

- Mutual Exclusion(상호 배제)
프로세스 P1이 Critical Section에서 실행중이라면, 다른 프로세스들은 그들이 가진 Critical Section에서 실행될 수 없다.

- Progress(진행)
Critical Section에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 Critical Section 진입 후보로서 참여될 수 있다.

- Bounded Waiting(한정된 대기)
P1가 Critical Section에 진입 신청 후 부터 받아들여질 때가지, 다른 프로세스들이 Critical Section에 진입하는 횟수는 제한이 있어야 한다.

## 단편화 정의와 종류를 설명하시오.

#### 단편화 (Fragmentation)

프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용 못할 만큼의 작은 조각의 자유공간들이 늘어나게 되고, 이것이 단편화 이다. 단편화는 2가지 종류로 나뉜다.

#### 외부 단편화

메모리 공간 중 일부 사용 못하게 되는 부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을때 발생한다고 볼 수 있다.

#### 내부 단편화

프로세스가 사용하는 메모리 공간 에 포함된 남는 부분. 예를들어 메모리 분할 자유 공간이 10,000B 있고 Process A가 9,998B 사용하게되면 2B라는 차이 가 존재하고, 이 현상을 내부 단편화라 칭한다.

## Priority Scheduling의 문제점과 해결책을 서술하시오.

#### 문제점

실행 준비는 되어있으나 CPU를 사용못하는 프로세스를 CPU가 무기한 대기하는 문제

#### 해결책

우선순위를 높여서 문제 해결

## 캐시의 시간지역성과 공간지역성에대해 설명하시오.

시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성.
공간 지역성 : 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성

## 요구 페이징의 정의와 장점

#### 정의

프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략

#### 장점

용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있다.

## Round Robin 특장점

#### 특징

- 현대적인 CPU 스케줄링
- 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.
- 할당 시간이 지나면 프로세스는 선점당하고 ready queue의 제일 뒤에 가서 다시 줄을 선다.
- RR은 CPU사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
- RR이 가능한 이유는 프로세스의 context를 save할 수 있기 때문이다.

#### 장점

- Response time이 빨라진다.
- n개의 프로세스가 ready queue에 있고 할당시간이 q(time quantum)인 경우 각 프로세스는 q단위로 CPU시간의 1/n을 얻는다. 즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
- 프로세스가 기다리는 시간이 CPU를 사용할 만큼 증가한다.
- 공정한 스케줄링이라고 할 수 있다.

#### 주의할 점

- 설정한 time quantum이 너무 커지면 FCFS와 같아진다. 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch로 overhead가 발생한다. 그렇기 때문에 적당한 time quantum을 설정하는 것이 중요하다.

[참조사이트](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS)

[jekyll-gh]:   https://github.com/quarl894